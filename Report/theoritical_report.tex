\documentclass[11pt]{article}
\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{adjustbox}
\usepackage{pifont}
\usepackage{ulem}
\usepackage{xcolor,colortbl}
\usepackage{pgfplots}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
\usepackage{amsmath}
\usepackage{xepersian}
\settextfont{XB Niloofar}
\setlatintextfont{Linux Libertine O}
\setdigitfont{XB Niloofar}
\title{تمرین هشتم درس معماری کامپیوتر}
\author{میلاد آقاجوهری ، شماره دانشجویی: ۹۴۱۰۵۴۷۴}
\begin{document}
\maketitle
\section{سوال اول}
\subsection{الف}
از روی تعداد بیت‌های ایندکس می‌تون به سادگی  محاسبه کرد که ما چند set داریم پس داریم که:
\begin{itemize}
\item سیستم اول:
در این سیستم هر set برابر با ۸ بیت اطلاعات و ۶ بیت برای ذخیره‌سازی tag ها نیاز دارد.پس هر خط یا هر set که در اینجا به علت نگاشت‌مستقیم بودن فرق چندانی با هم دیگر ندارند برابر با ۱۴ بیت حافظه نیاز دارد که ۶ بیت از آن برای tag مصرف می‌شود. در کل هم حافظه برابر با 
$(6+8)\times 2^{10} = 14336 bits$
که از این مقدار برابر با 
$\frac{6}{14} = 42\%$
آن برای بیت‌های tag مصرف شده است.
\item سیستم دوم:
با توجه به اینکه از تعداد بیت‌های اختصاص داده‌شده به offset می‌توان متوجه‌ شد که چندین بایت در یک خط از کش وجود دارد با توجه به این که مجموع بیت‌های تگ و ایندکس در این کش برابر با ۱۴ بیت است پس ۲ بیت برای offset باقی می‌ماند که بنابراین هر خط برابر با ۴ بایت است که طبق صورت سوال یک کلمه است.پس کلمات این سیستم ۳۲ بیتی هستند. حالا داریم که مقدار حافظه برابر با:
$$2^{7}\times 2_{(2-way)} \times (32bit + 7bit) = 9984bit$$
است.
مشخص است که 
$\frac{7}{39} = 17.9\%$
از حافظه‌‌ی سیستم به تگ‌بیت‌ها اختصاص داده‌شده‌است.
\item سیستم سوم:
این که کلمه برابر با ۳۲ بیت است که در قسمت قبل نتیجه شد و البته در این قسمت هم میتوان با توجه به اینکه تعداد بیت‌‌های باقیمانده برای offset برابر با ۲ ایت نتیجه گرفت،‌داریم:
$$2^8\times (32bit_{value} + 14bit_{tag}) = 11776bit$$
بنابراین نتیجه می‌گیریم که برابر با
$$\frac{14}{46} = 30.4\%$$
از حافظه به تگ‌بیت اختصاص داده شده است.
\end{itemize}
\subsection{ب}
هر چه مقدار associativity سیستم کمتر باشد احتمال می‌دهیم که نرخ عدم دسترسی بالاتر رود زیرا احتمال برخور‌د‌ها بیش‌تر می‌شود. پس نرخ عدم دسترسی ۵۰ درصد متعلق به سیستم اول، نرخ عدم دسترسی ۳۰ درصد متعلق به سیستم دوم و نرخ عدم دسترسی ۱۰ درصد متعلق به سیستم سوم است.
\subsection{پ}
ابتدا رابطه‌ی میانگین زمان دسترسی را به‌خاطر میآوریم:
$$AMAT = hit\_time  + miss\_rate \times (miss\_penalty)$$
پس داریم که:
\begin{itemize}
\item:
سیستم اول:
$$AMAT_{1} = 1  + 0.5 \times (20) = 11$$
\item:
سیستم دوم:
$$AMAT_{2} = 2  + 0.30 \times (20) = 8$$
\item:
سیستم سوم:
$$AMAT_{1} = 5  + 0.10 \times (20) = 7$$


\end{itemize}
\section{سوال دوم}
\subsection{الف}
اولا گفته‌شده‌است که هر خط از این حافظه دارای ۴ کلمه است بنابراین از آنجایی که هر کلمه برابر با ۴بایت اطلاعات است بنابراین نتیجه می‌گیریم که هر خط از این حافظه برابر با
$4 \times 4 = 16$
بایت از اطلاعات را در خود دارد.بیت‌های offset برای این هستند که در میان بایت‌های موجود در یک خط بتوانیم تشخیص دهیم که کدامین بایت در واقع بایت موردنظر ماست.چون در هر خط ما برابر با ۱۶ بایت اطلاعات داریم پس تعداد بیت‌های offset برابر با
$log(16) = 4$
خواهد بود.از طرفی با توجه به اینکه حجم حافظه‌‌ برابر با 
$8kb$
است و هر set دارای دو خط و بنابراین دارای 32 بایت اطلاعات است ما نتیجه می‌گیریم که برابر با
$\frac{8\times 1024}{32} = 256$
تا set داریم که بنابراین تعداد بیت‌های index ما برابر با 8 تا است. ازجایی که آدر‌س‌های این ماشین همه ۱۶ بیتی هستند پس ما ۴ بیت نیز برای tag نیاز خواهیم داشت:
$$tag = 16 - offset -index = 4$$
هم‌چنین از جایی که این کش برابر با ۲۵۶ عدد set دارد و هر set هم دو خط دارد پس این کش برابر با 
$256\times 2 = 512$
تا خط دارد.
\subsection{ب}
ابتدا دقت کنید که با توجه به اطلاعات به دست آمده در قسمت قبلی سوال میدانیم که ۴ بیت سمت راست در واقع ۴ بیت offset،
۸ بیت وسطی برابر با index و ۴ بیت سمت چپ برابر با ۴ بیت tag هستند. دقت کنید که برای این که بفهمیم که بایتی در حافظه موجود هست یا نه کافیست که از آدرس آن تنها در set ای که index به آن اشاره می‌کند، tag ان را موجود داشته باشیم زیرا که هنگام فراخوانی قسمتی از حافظه‌ی یک line به طور کامل به درون حافظه واکشی می‌وشد به طوری که هر offset ای داشته باشیم به سادگی می‌توان آن را در خطی که در حافظه‌ی نهان هست یافت.
با توضیحات بالا داریم:
\begin{latin}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
address & tag-index-available & hit/miss & compulsory?\\ \hline
0x1000  &      &miss & yes\\ \hline
0x1004  &  100    &hit  & no\\ \hline
0x1010  &  100    &miss & yes \\ \hline
0x11C0  &  100,101  &miss & yes\\ \hline
0x2000  &  100,101,11c  &miss & yes\\ \hline
0x21C0  &  100,101,11c,200    &miss & yes\\ \hline
0x3400  &  100,101,11c,200,21c    &miss & yes\\ \hline
0x3404  &  100,101,11c, 200, 21c,340  &hit & no\\ \hline
0x3F00  &  100,101,11c,200,21c,340    & miss & yes\\ \hline
0x2004  &  100,101,11c,200,21c,340,3F0 & hit & no\\ \hline
0x1004  &  100,101,11c,200,21c,340,3F0 &  hit & no\\ \hline
\end{tabular}
\end{center}
\end{latin}
با توجه بالا ما نرخ miss ما برابر با 
$\frac{7}{11} =63\%$
 و نرخ جایگزینی برابر با 
 $0\%$
  است.
\subsection{ج}
همانطور که در بالا توضیح داده‌شد، ما هیچ جایگزینی ای نداریم. بنابراین تغییرات گفته شده باعث تغییری در مقادیر خواسته شده نخواهد شد و جواب همانست که گفته شد:
پس نرخ miss ما برابر با 
$\frac{7}{11} =63\%$
 و نرخ جایگزینی برابر با 
 $0\%$
  است.

\section{سوال سوم}
در ابتدا فرض می‌کنیم که طول کلمه برابر با ۴ بایت است.فرض می‌کنیم که حافظه‌ی ما به هر بایت یک آدرس را اختصاص داده است.
\subsection{پیکربندی‌ اول}
از جایی که حافظه‌‌ی این کش برابر با 4KB است و هر بلوک آن برابر با ۳۲ بایت است پس داریم که در این حافظه ما به تعداد
$\frac{4\times 1024\;byte}{32\;byte} = 128\;line$
داریم.پس دو خانه‌ی متفاوت که آدرس‌های آن‌هاباقیمانده‌ی یکسانی بر ۱۲۸ دارند به یک خانه از کش اشاره می‌کنند و از جایی که اگر دو خانه متفاوت آدرس‌هایی با باقیمانده‌ی یکسان بر ۱۲۸ داشته باشند لااقل از یکدیگر برابر با ۱‍۲۸ بایت فاصله دارند، اما حافظه‌ی نهان ما در هر خط ۳۲ بایت جا دارد پس صدا کردن چنین آدرس‌هایی پشت سر هم miss خواهیم خورد.
\begin{itemize}
\item برنامه‌ی سمت چپ:
در هر بار اجرای اولین حلقه ما ۱۲۸ خانه را صدا می‌زنیم که هر جتف متوالی آن‌ها در حافظه از یکدیگر ۲۵۶ بایت فاصله دارند پس باقیمانده‌ی آدرس‌هایشان بر ۱۲۸ با هم برابر است. پس تمامی خواندن‌ها از حافظه miss خواهند خورد و
$$miss\_rate = 100\%$$
\item:برنامه‌ی سمت راست:
از جایی که با هر بار miss به تعداد ۳۲ بایت از آن در کش فراخوانی می‌شوند(۸ کلمه از سطر) و سپس ۷ کلمه‌ی دیگر به جز کلمه‌ی اولیه به ترتیب مورد دسترسی قرار میگیرند پس تنها کلمه‌ی اول هر بسته‌ی ۸ تایی از حافظه دچار miss میشود و بنابراین درصد missبرابر با
 $\frac{1}{8} = 12.5\%$
 است.
\end{itemize} 

\subsection{پیکر‌بندی‌ دوم}
در این‌جا هم از جایی که سایز کش برابر با 8kb است  و سایز هر بلوک برابر با ۳۲ بایت است محاسبه می‌شود که ما برابر با
 $\frac{8 \times 1024}{32} = 256$
 تا بلوک داریم و از هر جایی که هر set دو تا بلوک دارد بنابراین ما در کل 128 تا set داریم. 
 \begin{itemize}
\item برنامه‌ی سمت چپ:
در هر بار اجرای اولین حلقه ما ۱۲۸ خانه را صدا می‌زنیم که هر جفت متوالی آن‌ها در حافظه از یکدیگر ۲۵۶ بایت فاصله دارند پس باقیمانده‌ی آدرس‌هایشان بر ۱۲۸ با هم برابر است. پس تمامی خواندن‌ها از حافظه miss خواهند خورد و
$$miss\_rate = 100\%$$
(دقت کنید که در هر بار اجرای حلقه‌ی درونی چون فاصله‌ی تمام آدرس‌های پشت سر هم برابر با ۲۵۶ است و با توجه به محاسبات بالا ما یک بیت offset و ۷ بیت index داریم پس آدرس ‌هایی که فاصله‌شان از هم مصرب ۲۵۶ است به یک set نگاشت می‌شوند. پس با هر سیاست جایگزینی موقعی که خانه‌ی دوم یک سطر را می‌خواهیم قبلا بلوک مربوط به آن سطر از حافظه پاک شده است زیرا که پس از آن ۶۳ سطر جدید اضافه شده‌اند و قطعا آن بلوک با بلوک دیگری جایگزین شده‌است.)
\item:برنامه‌ی سمت راست:
از جایی که با هر بار miss به تعداد ۳۲ بایت از آن در کش فراخوانی می‌شوند(۸ کلمه از سطر) و سپس ۷ کلمه‌ی دیگر به جز کلمه‌ی اولیه به ترتیب مورد دسترسی قرار میگیرند پس تنها کلمه‌ی اول هر بسته‌ی ۸ تایی از حافظه دچار miss میشود و بنابراین درصد missبرابر با
 $\frac{1}{8} = 12.5\%$
 است.
\end{itemize} 
\subsection{پیکر‌بندی‌ سوم}
در این‌جا هم از جایی که سایز کش برابر با 8kb است  و سایز هر بلوک برابر با ۳۲ بایت است محاسبه می‌شود که ما برابر با
 $\frac{8 \times 1024}{32} = 256$
 تا بلوک داریم و از هر جایی که هر set دو تا بلوک دارد بنابراین ما در کل 128 تا set داریم. 
 \begin{itemize}
\item برنامه‌ی سمت چپ:
در هر بار اجرای اولین حلقه ما ۱۲۸ خانه را صدا می‌زنیم که هر جفت متوالی آن‌ها در حافظه از یکدیگر ۲۵۶ بایت فاصله دارند پس باقیمانده‌ی آدرس‌هایشان بر ۱۲۸ با هم برابر است. پس تمامی خواندن‌ها از حافظه miss خواهند خورد و
$$miss\_rate = 100\%$$
(دقت کنید که در هر بار اجرای حلقه‌ی درونی چون فاصله‌ی تمام آدرس‌های پشت سر هم برابر با ۲۵۶ است و با توجه به محاسبات بالا ما یک بیت offset و ۷ بیت index داریم پس آدرس ‌هایی که فاصله‌شان از هم مصرب ۲۵۶ است به یک set نگاشت می‌شوند. پس با هر سیاست جایگزینی موقعی که خانه‌ی دوم یک سطر را می‌خواهیم قبلا بلوک مربوط به آن سطر از حافظه پاک شده است زیرا که پس از آن ۶۳ سطر جدید اضافه شده‌اند و قطعا آن بلوک با بلوک دیگری جایگزین شده‌است.(دقت کنید سیاست جایگزینی تاثیری در اینجا ندارد زیرا که با سیاست FIFO هم اگر در یک سطر خانه‌ای فراخوانی شود، با آمدن ۶۳ سطر بعدی قطعا این خط از حافظه پاک خواهد شد زیرا زود تر از بقیه‌ی سطر‌های بعدش آمده است و وقتی به آن می‌رسیم دوباره که تمامی آن سطر‌ها یک مقدار را به کش و در واقع set یکسان اضافی کرده‌اند))
\item:برنامه‌ی سمت راست:
از جایی که با هر بار miss به تعداد ۳۲ بایت از آن در کش فراخوانی می‌شوند(۸ کلمه از سطر) و سپس ۷ کلمه‌ی دیگر به جز کلمه‌ی اولیه به ترتیب مورد دسترسی قرار میگیرند پس تنها کلمه‌ی اول هر بسته‌ی ۸ تایی از حافظه دچار miss میشود و بنابراین درصد missبرابر با
 $\frac{1}{8} = 12.5\%$
 است.(سیاست جایگزینی FIFO , LRU در اینجا هیچ تفاوتی با هم ندارند)
\end{itemize} 

\section{سوال چهارم}
در ابتدا به سادگی می‌توانیم مدت زمان لازم برای یک کلاک یا به اصطلاح سیکل کلاک را محاسبه کنیم. پردازنده 
$2GHz$
است و بنابراین طول زمانی هر کلاک برابر با
$\frac{1}{2\times 10^9} = 0.5ns$
است.
\begin{itemize}
\item سیاست اول:
در صورت استفاده از سیاست اول داریم:
$$AMAT_{policy1} = 0.9\times 2 + 0.1\times 0.98 \times 30 + 0.1\times 0.02 \times 250 = 5.24ns = \frac{5.24ns}{0.5ns} = 10.48cycles$$
و از جایی که ما 3000 دستور به این صورت داریم پس ما برابر با 
$$5.24 \times 3000 = 15720ns = \frac{15720}{0.5} = 31480cycles$$
زمان صرف شده است.
\item سیاست دوم :
در صورت استفاده از سیاست دوم داریم:
$$AMAT_{policy1} = 2 + 0.1 \times 30 + 0.1\times 0.02 \times 250 = 5.5ns = \frac{5.5ns}{0.5ns} = 11cycles$$
و از جایی که ما 3000 دستور به این صورت داریم پس ما برابر با 
$$5.5 \times 3000 = 16500ns = \frac{16500}{0.5} = 33000cycles$$
زمان صرف شده است.

\end{itemize}
\section{سوال پنجم}
برای هر دنباله
یک کش ارایه می‌دهیم که تمامی
\lr{miss\_rate}
ها را برای تمامی دنباله‌های داده‌شده رعایت کند. این که چه اطلاعاتی از هر دنباله در مورد کش به دست می‌آید را می‌نویسیم.بقیه موارد اهمیتی ندارند که چه مقداری بگیرند.
\begin{itemize}
\item دنباله‌‌ی اول:
از جایی که در دنباله‌ی اول فاصله‌ بین آدرس‌های متوالی به صورت
\lr{0,2,4,8,16,32}
استو از خانه‌‌ی صفر حافظه هم شروع کرده‌ایم، این تعداد بیت‌های offset است که تعیین کننده‌ی مقدار 
\lr{miss\_rate}
خواهد شد.چون می‌خواهیم که 4 تا miss داشته‌باشیم، پس باید offset ما به گونه‌ای باشد که تنها سه تا از این ۶ تا آدرس را یک دسته کند پس تعداد بیت‌های offset باید برابر با ۳ تا باشد و این یعنی سایز بلوک‌ها باید برابر با ۸ باشد.بقیه موارد اهمیتی ندارند و هر چیزی می‌توانند باشند.
\item دنباله‌ی دوم:
از جایی که فاصله‌ی متوالی آدرس‌های داده‌شده برابر با ۵۱۲ است که بسیار بیش تر از تمامی اندازه بلوک‌هاست پس آن موضوع اهمیتی ندارد(اندازه بلوک را یک بگیرید). در ابتدا تمامی آدرس‌های 
\lr{0,512,1024,1536,2048}
miss خواهند خورد.
حال باید در میان ۴ آدرس بعدی تنها یکی از آن‌ها miss بخورد، دقت کنید که در آدرس‌های داده شده تمامی ۹ بیت کم ارزش صفر هستند و برای یک حجم معقول از کش در این سوال، لازم نیست ما بیش از ۶۴ set داشته باشیم و برای همین هم این دنباله را باید با استفاده از 
\lr{associativity}
ها حل کنیم.۵ آدرس اول از جایی که تکراری ندارند و طول بلوکی که در هر بار miss واکشی می‌شود هم ۸ بایت است پس تمامی miss میخورند. تمامی ۴ آدرس بعدی تکراری هستند و باید یکی از آن‌ها miss بخورد و برای همین کافیست که 
\lr{4-way associativity}
داشته‌باشیم(دقت کنید چون ۹ بیت کم‌ارزش تمامی آدرس‌های خواسته‌شده در صورت سوال برابر صفر است پس تمامی آن‌ها به set اول یا به بیانی set صفر‌م نگاشت می‌شوند).
پس حجم یک کش معقول کمتر مساوی 
$64 \times 4 byte = 256\;byte$
است و اندازه‌ی بلوک را ۱ میگیریم.سیاست جایگزینی مهم نیست هر کدام می‌تواند باشد.
\item دنباله‌ی سوم:
اگر associativity برابر با 4 باشد و ما در حافظه‌مان برابر با ۶۴ تا set داشته باشیم و اندازه‌‌‌ی بلوک هم برابر با یک بایت باشد پس حافظه‌مان ۲۵۶ بایت دارد. از طرفی سیاست جایگزینی هر‌ کدام از سیاست‌های گفته‌شده می‌تواند باشد.به این صورت تمامی آدرس‌های ما به set با ایندکس صفر نگاشت می‌شوند و بنابراین پس از ۵ آدرس اول یکی از ۴ آدرس اول دیگر موجود نخواهد بود و آن هم miss خواهد خورد و ۰.۳۳ درصد نرخ دسترسی به دست خواهد‌ آمد.
\item دنباله‌ی چهارم:
اگر associativity برابر با 4 باشد و ما در حافظه‌مان برابر با ۶۴ تا set داشته باشیم و اندازه‌‌‌ی بلوک هم برابر با یک بایت باشد پس حافظه‌مان ۲۵۶ بایت دارد.سیاست جایگزینی را LRU برمی‌گزینیم. حالا
تا اینجا  
\lr{0, 512, 1024, 0, 1536}
ما چهار تا miss میخوریم و یک hit که برای صفر است. حال با آمدن ۱۵۳۶ در آخر ما تمامی چهارخانمان پر شده. حال با استفاده‌ی دوباره از ۰و سپس آمدن ۲۰۴۸ خانه‌ای که دیرترین بار استفاده شده همان بلوکی است که در آن خانه‌ی ۵۱۲ نوشته‌شده.پس در آن خانه نوشته شده و نتیجتا ۵۱۲ آخری miss خواهد خورد زیرا روی بلوک آن نوشته‌ می‌شود.نتیجه می‌گیریم که تنها دو آدرس صفر آمده hit می‌شوند و بنابراین درصد hit برابر با 25\% می‌شود.
\end{itemize}
\section{سوال ششم}
جواب این سوال بسیار ساده و زیباست. تا وقتی که نگاشت ما به صورت مستقیم باشد با توجه به این‌که بلاکی که ممکن است مقدار مورد نظر ما در آن باشد به صورت یکتا مشخص می‌شود می‌توان انتقال داده را قبل از آمدن سیگنالی که hit یا miss شدن را اطلاع می‌دهد انجام داد و بنابراین در اینجا سیگنال hit miss است که در مسیر بحرانی است. اما در در مورد کش‌هایی که setassociative هستند، ابتدا باید بین تعدادی بلوک مقایسه با تگبیتها انجام شود و سپس داده منتقل شود که به این صورت دیگر خوداین فرایند در مسیر بحرانی است و داده بعد از سیگنال hit یا miss میرسد(زیرا hit شدن یا miss شدن در واقع باید محاسبه شد تا انتقال را شروع کنیم). پس در حالت دوم یک کندی عظیم برای این تاخیر خواهیم داشت که باعث ایجاد یک کندی شدید بین نگاشت  مستقیم و set associative می‌شود.
\section{سوال هفتم}
\subsection{الف}
با توجه به این‌که ذکر شده‌است که داده‌هایی که به آن‌ها نیاز داریم در حافظه به صورت تصادفی پخش‌ شده‌اند پس 
\lr{spatial locality}
چندانی را در آن‌ها شاهد نیستیم.
اما در مورد دستورات چون دستورات یا پشت سر‌هم اجرا می‌شوند یا حداکثر به پنج دستور قبل برمی‌گردیم پس دارای
\lr{spatial locality}
بالایی هستند.
\subsection{ب}
تنها در حالاتی ما 
\lr{temporal locality}
در مورد داده‌ها خواهیم‌داشت که در حال اجرای دستور branch باشیم زیرا در آن صورت دوباره به همان مکان داده‌هایی که قبلا نیاز داشتیم، نیاز داریم اما این تنها در ۵ درصد از دستورات اتفاق می‌افتد(البته ممکن است یک حلقه بسیار طول بکشید که در این صورت شاید temporal locality برنامه زیاد شود و اکثر زمان برنامه در حین اجرای همین حلقه‌ها باشد که در این صورت برای مثال در مورد متغیر شمارنده‌ی حلقه ما همیشه در حال دسترسی به همان متغیر هستیم).
\newline
اما در همجواری مکانی به دستور ما همیشه 
\lr{spatial locality}
را داریم و بنابراین می‌توان گفت که این نوع همجواری مکانی در حافظه‌ی نهان دستور بیش‌تر از همجواری زمانی
\lr{temporal locality} 
در حافظه‌ی نهان داده اتفاق خواهد‌افتاد.
\subsection{پ}
با توجه به این که دستورات پشت سر یکدیگر اجرا می‌شوند و حتی در صورت رسیدن به دستورات برنچ تنها حداکثر ۵ دستور به عقب برمی‌گردند بنابراین می‌توانیم نتیجه بگیریم که هر دو نوع
\lr{locality}
در دستورات بالا هستند پس در اکثر موارد ما دسترسی خواهیم داشت و بنابراین میزان دسترسی بسیار بیش‌تر از میزان عدم دسترسی است.
\subsection{د}
درمورد دستورات از جایی که داده‌های مورد نیاز ما به صورت تصادفی در حافظه پخش‌شده‌اند پس ما miss زیاد داریم اما در مواقعی که میخواهیم عمل store را انجام دهیم اگر فاصله‌ي زمانی زیادی با خود خواندن مقدار نداشیته باشیم hit داریم اما میدانیم که دستورات load ۴ برابر دستورات store هستند (در این برنامه‌ی خاص) و بنابراین میزان عدم دسترسی بالاست.
\section{سوال هشتم}
در این سوال آدرس ۸ بیتی است زیرا که حافظه‌ی ما تنها گنجایشی برابر با ۲۵۶ بایت دارد.
\subsection{الف}
طبق اطلاعات داده‌شده در صورت سوال،‌ در این کش ما ۴ set خواهیم‌داشت و همچنین در هر set تنها یک بلوک ۴ بایتی موجود است.پس در مورد تقسیم‌بندی آدرس داریم که از راست به سمت چپ در نمایش دودویی آدرس ما ۲ بیت اولی برای offset، دو بیت برای index و ۴ بیت مابقی آن tag است.

برنامه‌ی ما شامل دو حلقه است. در حلقه‌ی اول توالی آدرس‌های فراخوانی شده به صورت
\newline
\lr{E0, E1, E2, E3, E4, ...}
است.از جایی که آدرس‌ها متوالی هستند و همچنین خانه‌ی اول خانه‌ای با offset صفر است پس از بین تمامی چهارتایی‌های پشت‌ سر هم بدون در نظر گرفتن بقیه‌ی موارد ما داریم که تنها اولین خانه miss می‌خورد.چون ۲۵ خانه هستند پس برابر با 
$\lceil \frac{25}{4} \rceil = 7$
خانه miss خواهند خورد.\newline
قسمت زیبای سوال در حلقه‌ی دوم اتفاق می‌افتد.چون در حلقه‌ی قبلی شماره‌ی setها استفاده شده به صورت
\lr{0, 1, 2, 3, 2, 1, 0}
بوده است پس set با ایندکس ۳ در اینجا هنوز خانه‌های خود را دارد و بنابراین حتی اولین خانه‌ی آن هم  در حلقه‌ی دوم miss نخواهد شد. اما بقیه‌ی شماره‌ها چرا.بنابراین نتیجه می‌گیریم که خانه‌ی اول تمامی چهارتایی‌ها به جز چهارتایی‌های مرتبط با آدرس‌هایی که در set با ایندکس ۳ کار دارند miss خواهد خورد که برابر با 6 miss خواهد شد.
پس داریم که در این ۵۰ درخواست داده‌شده روی هم‌دیگر ۱۳ تا miss داشته‌ایم و بنابراین نرخ عدم دسترسی برابر با 26 درصد است.
\subsection{ب}
هر set،دو تا بلوک دو بایتی دارد و بنابراین هر set ۴ بایت دارد. پس چون کش ما ۳۲ بایتی است پس ما ۸ تا set داریم.پس در مورد تقسیم‌بندی آدرس داریم که از راست به سمت چپ در نمایش دودویی آدرس ما یک بیت اولی برای offset، سه بیت برای index و ۴ بیت مابقی آن tag است.
\newline
در حلقه‌ی اول به علت این‌که بلوک‌های ما دو بایتی هستند و هم‌چنین از آدرسی با offset برابر با صفر شروع می‌شوند پس برای هر دو بایت متوالی ما تنها یک miss خواهیم داشت و این miss برای آدرس اول هر جفت دوتایی اتفاق می‌افتد پس داریم که برابر با 
$\lceil \frac{25}{2} = 13\rceil$
miss خواهیم داشت.
سیاست جایگزینی تاثیری در این سوال ندارد زیرا که هیچ داده‌ای از cache به بیرون انداخته نمی‌شود و علت آن این است که برای این که داده‌ای از cache‌ای که به صورت
\lr{2way-associative} 
 است بیرون انداخته‌شود باید در لحظه‌ای که دو آدرس با index یکسان و tag‌های متفاوت در cache داریم،‌یک آدرس دیگر با همان index و با tag ای متفاوت اضافه شوداما در این سوال ما در این بین ۲۵ آدرس ما کلا دو مقدار tag داریم در آدرس‌ها(E , F)بنابراین ممکن نیست در آدرس‌هایمان با یک ایندکس ما سه مقدار tag داشته‌باشیم.پس هیچ داده‌ای دور انداخته نمی‌شود.
 \newline
 در حلقه‌ی دوم با توجه به اینکه تمامی داده‌ها در کش حضور دارند، هیچی miss ای نخواهیم داشت.
 \newline
 پس در کل در این مورد ما ۱۳ تا miss از این ۵۰ دستور خواهیم‌داشت که 26\% تا از آن‌‌ها miss شده‌است. 
\subsection{پ}
اولا دقت کنید که چون سایز بلوک‌های ما ۴ تایی است بنابراین همانطور که در قسمت اول توضیح دادیم در اینجا ما 
$\lceil \frac{25}{4}\rceil = 7$
miss 
خواهیم‌داشت.
\newline
برای تحلیل حلقه‌ی دوم کافیست توجه کنیم که چه بلوک‌هایی را در حافظه داریم. با توجه به سیاست LRU که استفاده شده‌است در پایان عملیات بالا ما اگر بسته‌های اعدادد را ۴ تا ۴ تا در نظر بگیریم.۳ بسته‌ی اول را در حافظه نداریم(در کل ۷ بسته ۴ تایی داده داریم). حال در ترتیب اجرا اولین بسته را نداریم. بنابراین یک miss می‌خوریم، و بسته‌ی چهارم که در کش مانده بود خارج می‌شود(به علت سیاست write-allocate) و به همین ترتیب. بنابراین تمامی بسته‌ها قبل از اینکه به ان‌ها در حلقه‌مان برسیم از دسترسی ما خارج می‌شوند و ما برای تمامی آنها مثل  حقله‌ی اول miss خواهیم خورد. پس در اینجا ما هفت miss خواهیم‌داشت.
\section{سوالات عملی اول}
\subsection{الف}
\begin{latin}
\begin{adjustbox}{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
\rowcolor{black!30}
\cellcolor{white}
\multirow{2}{*}{Number of sets / ways} & \multicolumn{2}{c|}{1-way} & \multicolumn{2}{c|}{2-way} & \multicolumn{2}{c|}{4-way} & \multicolumn{2}{c|}{8-way} \\ \cline{2-9}
&\cellcolor{black!30} I-Cache &\cellcolor{black!30} D-Cache &\cellcolor{black!30} I-Cache &\cellcolor{black!30} D-Cache &\cellcolor{black!30} I-Cache &\cellcolor{black!30} D-Cache &\cellcolor{black!30} I-Cache &\cellcolor{black!30} D-Cache \\ \hline
\cellcolor{black!30}32 sets	&
$0.2749$&$ 0.1041$&$0.1737$&$0.0904$&$0.0982$&$0.0870$&$0.0821$&$0.0869$ \\ \hline
\cellcolor{black!30}64 sets	&
$0.1881$&$0.0977$&$0.1098$&$0.0877$&$0.0811$&$0.0870$&$0.0428$&$0.0869$ \\ \hline
\cellcolor{black!30}128 sets	&
$0.1226$&$0.0924$&$0.0796$&$0.0870$&$0.0429$&$0.0869$&$0.0302$&$0.0834$ \\ \hline
\cellcolor{black!30}256 sets	&
$0.0823$&$0.0901$&$0.0478$&$0.0870$&$0.0307$&$0.0839$&$0.0300$&$0.0834$ \\ \hline
\cellcolor{black!30}512 sets	&
$0.0548$&$ 0.0878$&$0.0334$&$0.0839$&$0.0300$&$0.0834$&$0.0300$&$0.0834$ \\ \hline
\end{tabular}
\end{adjustbox}
\end{latin}

\subsection{ب}
\subsubsection{instruction-cache}
 خطوط از بالا به پایین(آبی،‌قرمز،زرد،سبز،بنفش) مربوط به(۳۲و ۶۴و ۱۲۸و ۲۵۶و ۵۱۲) set هستند.
\includegraphics[scale=0.7]{chart1}
\subsubsection{data-cache}
\includegraphics[scale=0.7]{chart2}
\subsection{پ}
\begin{latin}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\rowcolor{black!30}
Number of sets / ways&1-way&2-way&4-way&8-way \\ \hline
32 sets	&0.2749&
0.1661&
0.1043&
0.0782 \\ \hline
64 sets	&0.1881&
0.1093&
0.0796&
0.0487 \\ \hline
128 sets&0.1226&
0.0795&
0.0488&
0.0370 \\ \hline
256 sets&0.0823&
0.0511&
0.0361&
0.0328 \\ \hline
512 sets&0.0548&
0.0363&
0.0325&
0.0311 \\ \hline
\end{tabular}
\end{center}
\end{latin}
با سادگی قابل مشاهده است که به جز حالت 
\lr{1-way}
که به علت این که سیاست جایگزینی رندوم و LRU فرقی ندارند(یک خط در هر set بیشتر نیست) فرقی با یکدیگر ندارند. اما در بقیه‌ی موارد در اکثر موارد عملکرد الگوریتم LRU بهتر است که منطقی است زیرا به هر حال طبق منطقی کار می‌کند و نه تصادفی.
\subsubsection{د}
\begin{itemize}
\item کاهش نرخ عدم دسترسی
\item کاهش نرخ عدم دسترسی
\item با توجه به نمودار‌هایی که به دست آورده‌ایم به  نظر می‌رسد که در این سوال خاص باعث کاهش نرخ عدم دسترسی می‌شود اما جواب دادن به این مساله به صورت کلی به نظر نمی‌آید ممکن باشد.
\item در اینجا من حافظه‌ی نهان دستور را به صورت 2way 
و ۱۲۸ set عه انتخاب میکردم.
\item
حافظه‌ی ۳۲ set عه‌ی 
\lr{8way}
را انتخاب می‌کردم.
\end{itemize}
\section{سوال دوم}
در cw گفته‌ شده‌است است که بهتر است حافظه‌ی نهان سطح دوم را با تعداد ۲۵۶ و 
\lr{4way}
بگیریم.همچنین طبق رایزنی‌های انجام شده با بچه‌ها فرمول محاسبه‌ی 
AMAT
به صورت:
$$AMAT = hitT_{l1} \times missRate_{L1} \times (hitT_{L2} + missRate_{L2} \times hitT_{Mem})$$
پس داریم که:
طبق نتایج شبیه سازی زمان دسترسی به کش سطح ۱ ، ۱ سیکل کلاک، سطح ۲ ، ۶ سیکل کلاک و حافظه‌ی اصلی 80(زیرا که برای وا کشی اولین ۸بایت به ۱۸ سیکل و برای بعدي ها ۲ سیکل نیاز داریم که بنابراین می‌شود در نهایت ۸۰ سیکل(باید ۳۲ تا هشت بیت را به داخل کش دوم بکشیم)) کلاک.

\begin{latin}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\rowcolor{black!30}
L1-size	& \#set&Block size	&	CPI	 & L1 MR & L2 MR & 	AMAT\\ \hline
32KB	&	1024	&		16		&$0.5957$&$0.0178$&$0.0324$&$1.1529376$\\ \hline
32KB	&	512		&		32		&$0.5952$&$0.0096$&$0.0606$&$1.1041408$\\ \hline
32KB	&	256		&		64		&$0.5949$&$ 0.0052$&$0.1107$&$1.0772512$\\ \hline
32KB	&	128		&		128		&$0.5946$&$0.0030$&$0.1930$&$1.06432$\\ \hline
32KB	&	64		&		256		&$0.5945$&$0.0017$&$0.3438$&$1.0569568$\\ \hline
\end{tabular}
\end{center}
\end{latin}
اما در مورد نمودارها، در مورد نمودار AMAT داریم:\newline
\includegraphics[scale=0.7]{chart3}
در مورد نمودار CPI داریم:
\newline
\includegraphics[scale=0.7]{chart4}
\newline
می‌بینیم که با افزایش اندازه‌ی بلوک‌ها(که کاهش set ها نتیجه‌ی آن خواهد بود وقتی می‌خواهیم که اندازه‌ی کش تغییر نکند) AMAT کاهش یافته که نتیجه‌ی طبیعی آن کاهش CPI است اما چرا این اتفاق افتاده؟ معمولا افزایش اندازه‌ی بلوک در هنگامی خوب است که لوکالیتی فضایی برنامه‌ها بالا باشد و به نظر در برنامه‌ ‌ی مورد تست من لوکالیتی فضایی زیادی وجودداشته.


\end{document}